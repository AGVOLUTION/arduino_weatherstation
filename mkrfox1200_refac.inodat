/*************
 * TODO
 * 1. There is a dead time for rain count events during wind sampling and SigFox transmission
 * 
 * Energy Consumption
 * 1. Serial1 usage makes approx. 50uA in Stop Mode
 * 2. 19uA in Stop Mode without any shields
 * 3. 19uA in Stop Mode + SD Proto Shield without SD Card
 * 4. 740uA in Stop Mode when SD Card is suddenly inserted or not properly initialized
 * 5. 93uA in Stop Mode + SD Proto Shield + SD Card properly initialized (SPI + SD Controller shutdown current ca. 74uA (it is not the SD shutdown current!)) ==> SD library costs 70uA in Stop Mode
 * 6. Wire.h library + Wire.begin (I2C master) -> no additional shutdown current (no slaves plugged)
 * 7. RTCZero approx 2uA in Stop Mode
 * 8. SigFox 16mA in active mode, additional 20uA in Stop Mode (SigFox.end())
 * 9. Input pullups do not really make a difference
 * 10. External Serial1 makes around 100uA in Stop Mode and can't simply be 'ended' by Serial.end() (-> requires additional register modifications to restore lowest stop current)
 * 11. USB Serial is not drawing any stop mode current!
 */

#include "Inc/commission/commission.h"
#include "Inc/payload_format/payload_format.h"

// Include basic modules
#include "ArduinoLowPower.h"
#include <RTCZero.h>
#include <SigFox.h>
#include <Wire.h>
#include <SD.h>
#include "BlueDot_BME280.h"

// Declare new payload buffer
payload_t payload;

/* For debug purpose */
#define DEBUG_SERIAL            0 // printf debugging using Serial1 (RX/TX pins 13/14)
#define DEBUG_NO_LPMODE         0 // use delay instead of low power mode -> routing and wakeup interrupts wont work
#define DEBUG_SKIP_TX           0 // skip data packet transmission
#define DEBUG_LED               0 // use debug led to display on / low power state

/* Specify hardware layout */
#define DAVIS_RAIN_Pin          0
#define DS18B20_Pin             7
#define WM_EXC2_Pin             5
#define WM_EXC1_Pin             2
#define DAVIS_WIND_SPD_Pin      1
#define WM_B_Pin                1
#define WM_A_Pin                A5
#define WM_RESISTANCE_Pin       A6
#define WM_SWITCH_SUP           A4
#define DAVIS_WIND_DIR_Pin      A5
#define DAVIS_WIND_SUP_Pin      A4
#define AGV_MOISTURE_EN_Pin     A3
#define GPS_SUP_Pin             A2
#define LEAFWET_SIG_Pin         A1
#define LEAFWET_SUP_Pin         A0
#define SDLOG_CS_Pin            4

// wake-up routing
#define lpmodeWkupReasonSize 3
typedef enum __lpmodeWkupReason_t {
  lpmodeWkupReasonReport,
  lpmodeWkupReasonDavisWind,
  lpmodeWkupReasonDavisRain
} lpmodeWkupReason_t;

// Global flag which is set by interrupt callbacks causing the wake up
lpmodeWkupReason_t wkupReason = lpmodeWkupReasonReport;
// Global flag which stores RTC wakeup reasons specifically
lpmodeWkupReason_t rtcAlarmEvent = lpmodeWkupReasonReport;
// Last transmit time
static uint32_t ostimeLastPacketTx = 0;

// RTC Handle
RTCZero rtc;

#if EQUIP_BME76
// BME 0x76 handle
BlueDot_BME280 bme1;
#endif

#if EQUIP_DAVIS_RAIN
// Rain Count handle
rainCount_t rainCount;
#endif

#if EQUIP_DAVIS_WIND
// Davis Wind handle
davisWind_t davisWind;
#endif

#if EQUIP_SDLOG
// SD LOG handle
sdlog_t sdlog;
#endif

void setup() {
  #if DEBUG_SERIAL
  // Setup UART
  Serial1.begin(38400);
  Serial1.println(F("*************************************************"));
  Serial1.println(F("*A G V O L U T I O N    M A C R O C L I M A T E *"));
  Serial1.println(F("*************************************************"));
  #endif

  // Setup Real Time Clock RTC
  rtc.begin();

  uint8_t sigfoxState = SigFox.begin();

  #if DEBUG_SERIAL
  Serial1.print(F("SigFox State: "));
  Serial1.println(sigfoxState);
  #endif

  if (!sigfoxState) {
    // Something is really wrong, try rebooting
    // Reboot is useful if we are powering the board using an unreliable power source
    // (eg. solar panels or other energy harvesting methods)
    reboot();
  }

  String version = SigFox.SigVersion();
  String ID = SigFox.ID();
  String PAC = SigFox.PAC();

  Serial.begin(38400); // output SigFox parameters over USB serial in any case
  Serial.println("SigFox FW version " + version);
  Serial.println("ID  = " + ID);
  Serial.println("PAC = " + PAC);

  #if DEBUG_SERIAL
  Serial1.println("SigFox FW version " + version);
  Serial1.println("ID  = " + ID);
  Serial1.println("PAC = " + PAC);
  #endif

  //Send module to standby until we need to send a message
  SigFox.end();

  #if EQUIP_SDLOG
  // Initialize SD Card
  if (!SD.begin(SDLOG_CS_Pin)) {
    #if DEBUG_SERIAL
    Serial1.println(F("SD card failed or not present."));
    #endif
    sdlog.cardPresent = 0;
  }
  else {
    #if DEBUG_SERIAL
    Serial1.println(F("SD card initialized."));
    #endif
    sdlog.cardPresent = 1;
  }

  if(sdlog.cardPresent) {
    File headerfile = SD.open("header.txt", FILE_WRITE);
    if (! headerfile) {
      #if DEBUG_SERIAL
      Serial1.println(F("Error opening SD headerfile."));
      #endif
    }
    String headerString = "T,RH,P,WIND_DIR,WIND_SPD_AVG,WIND_SPD_STD";
    headerfile.println(headerString);
    headerfile.close();
  
    sdlog.datafile = SD.open("log.txt", FILE_WRITE);
    if (! sdlog.datafile) {
      #if DEBUG_SERIAL
      Serial1.println(F("Error opening SD logfile."));
      #endif
    }
  }
  #endif
  
  // Setup GPIOs
  setupGpios();

  // Attach wakeup interrupts
  attachWakeupInterrupts();

  // Setup BME280
  #if EQUIP_BME76
  setupBME280(&bme1);
  #endif

  // Setup raincount peripheral
  #if EQUIP_DAVIS_RAIN
  setupRainCount(&rainCount);
  #endif

  // Reset RTC
  rtcReset();

  #if DEBUG_SERIAL
  Serial1.println(F("Setup completed."));
  Serial1.println();
  #endif
}

void setupGpios() {
  #if EQUIP_DAVIS_RAIN
  pinMode(DAVIS_RAIN_Pin, INPUT_PULLUP);
  // attachInterrupt(digitalPinToInterrupt(DAVIS_RAIN_Pin), davisRainCountIncrement, FALLING);
  #endif

  #if EQUIP_DAVIS_WIND
  pinMode(DAVIS_WIND_SPD_Pin, INPUT_PULLUP);
  pinMode(DAVIS_WIND_SUP_Pin, OUTPUT);
  #endif

  pinMode(LED_BUILTIN, OUTPUT);
}

void attachWakeupInterrupts() {
  // Attach wake-up interrupts during LPMODE
  #if EQUIP_DAVIS_RAIN
  LowPower.attachInterruptWakeup(DAVIS_RAIN_Pin, lpmodeInterruptDavisRain, FALLING);
  #endif
  LowPower.attachInterruptWakeup(RTC_ALARM_WAKEUP, lpmodeInterruptRTC, CHANGE);
}

uint32_t rtcGetTimeSeconds(uint32_t *t) {
  *t = rtc.getSeconds() + 60*(rtc.getMinutes() + 60*(rtc.getHours() + 24*rtc.getDay() ) );
}

void rtcReset() {
  rtc.setSeconds(0);
  rtc.setMinutes(0);
  rtc.setHours(0);
  rtc.setDay(1);
  rtc.setMonth(1);
  rtc.setYear(1);
}

void loop() {
  // Enter low power mode by default
  lpmodeEnterStop();

  // After wakeup, act based on return value
  //Serial1.print(F("wkupReason="));
  //Serial1.println(wkupReason);
  switch(wkupReason) {
    case lpmodeWkupReasonReport:
      #if DEBUG_SERIAL
      Serial1.println(F("REPORT"));
      #endif
      report();
    break;
    case lpmodeWkupReasonDavisWind:
      #if DEBUG_SERIAL
      Serial1.println(F("DAVIS_WIND"));
      #endif
      davisWindAddSpdSample();
    break;
    case lpmodeWkupReasonDavisRain:
      #if DEBUG_SERIAL
      Serial1.println(F("DAVIS_RAIN"));
      #endif
      // Increment rain counter by one
      davisRainCountIncrement();
    break;
    default:
    // do nothing
    break;
  }
}

/* Transmit a data packet.
 *
 */
void report() {
  #if DEBUG_SERIAL
  Serial1.println(F("SigFox Module Boot"));
  #endif

  // Start the module
  SigFox.begin();
  //#if DEBUG_LED
  SigFox.debug();
  //#endif
  
  // Submit sensor read tasks
  #if EQUIP_BME76
  #if DEBUG_SERIAL
  Serial1.println(F("Trigger BME280"));
  #endif
  bme1.writeCTRLMeas(); // Trigger BME280 measurement by writing mode parameter (set to force) again
  #endif

  // Turn on voltage supply for wind poti
  #if EQUIP_DAVIS_WIND
  #if DEBUG_SERIAL
  Serial1.println(F("Turn on DAVIS_WIND_SUP"));
  #endif
  digitalWrite(DAVIS_WIND_SUP_Pin, HIGH);
  #endif

  // Wait (BME280 measurement, WIND supply stabilization, SigFox boot (at least 100ms))
  delay(100);

  // Read davis wind poti voltage
  #if EQUIP_DAVIS_WIND
  #if DEBUG_SERIAL
  Serial1.println(F("Read DAVIS_WIND_DIR"));
  #endif
  double davisWindPoti;
  analogReadResolution(10);
  davisWindPoti = analogRead(DAVIS_WIND_DIR_Pin);
  digitalWrite(DAVIS_WIND_SUP_Pin, LOW);
  // ADC resolution is set to 10 bit -> 0 = 0째, 1023 = 360째
  double davisWindDirDeg = davisWindPoti / 1023.0 * 360.0;
  #endif

  #if EQUIP_BME76
  payload.temperature = round(bme1.readTempC() * 100); // in 0.01 째C
  payload.humidity = round(bme1.readHumidity()); // in percent
  payload.pressure = round(bme1.readPressure() * 10); // in 0.1 hPa
  #endif

  #if EQUIP_DAVIS_RAIN
  payload.rainCount = rainCount.current;
  payload.rainCountAcc = rainCount.acc;
  // Reset rain counter
  rainCount.current = 0;
  #endif

  #if EQUIP_DAVIS_WIND
  payload.windDirAndError = (uint8_t)(round(davisWindDirDeg / 4.0)) << 1; // in 4째 steps
  payload.windSpdAvg = round(davisWindSpdAvg());
  payload.windSpdStd = round(davisWindSpdStd());
  // Reset wind sample counter
  davisWind.sample = 0;
  #endif

  #if DEBUG_SERIAL
  Serial1.println();
  Serial1.println(F("Payload Message:"));
  Serial1.println("    Temperature: " + String(payload.temperature));
  Serial1.println("       Humidity: " + String(payload.humidity));
  Serial1.println("       Pressure: " + String(payload.pressure));
  Serial1.println("      rainCount: " + String(payload.rainCount));
  Serial1.println("   rainCountAcc: " + String(payload.rainCountAcc));
  Serial1.println("windDirAndError: " + String(payload.windDirAndError));
  Serial1.println("     windSpdAvg: " + String(payload.windSpdAvg));
  Serial1.println("     windSpdStd: " + String(payload.windSpdStd));
  Serial1.println();
  #endif

  // Clears all pending interrupts
  SigFox.status();
  delay(1);

#if !DEBUG_SKIP_TX
  // Transmit Sigfox message
  SigFox.beginPacket();
  SigFox.write((uint8_t*)&payload, 12);
  // May take 10 seconds
  int ret = SigFox.endPacket();

  #if DEBUG_SERIAL
  Serial1.print(F("Sigfox status (0=OK): "));
  Serial1.println(ret, DEC);
  #endif
#endif
  SigFox.end();

  // Set internal time to zero after each data packet
  rtcReset();
}

/*  Call this method to enter low power state.
 *  RTC wake up is configured automatically.
 */
void lpmodeEnterStop() {
  #if DEBUG_SERIAL
  Serial1.println();
  Serial1.println(F("Entering LPMODE"));
  
  uint32_t nowTimeSeconds;
  Serial1.print(F("       RTC Time: "));
  rtcGetTimeSeconds(&nowTimeSeconds);
  Serial1.println((int)nowTimeSeconds, DEC);
  #endif
  
  // Switch off builtin LED to signal low power mode
  digitalWrite(LED_BUILTIN, LOW);
  // calculate time delta until next wakeup alarm
  int delayUntilNextWakeup = lpmodeScheduleWakeup();
  delayUntilNextWakeup *= 1000; // from milliseconds to seconds
  #if DEBUG_NO_LPMODE
  delay(delayUntilNextWakeup);
  #else
  // enter low power mode and schedule wakeup alert
  LowPower.sleep(delayUntilNextWakeup);
  #endif

  #if DEBUG_LED
  digitalWrite(LED_BUILTIN, HIGH);
  #endif
  
  #if DEBUG_SERIAL
  Serial1.println(F("Waking up from LPMODE"));
  Serial1.print(F("       RTC Time: "));
  rtcGetTimeSeconds(&nowTimeSeconds);
  Serial1.println(nowTimeSeconds, DEC);
  Serial1.println();
  #endif
  return;
}

/* Schedule the next wakeup alarm. */
int lpmodeScheduleWakeup() {
  // Specify a mapping from list indizes (0..N) -> lpmodeWkupReason ENUM
  lpmodeWkupReason_t mp[lpmodeWkupReasonSize];
  mp[lpmodeWkupReasonReport] = lpmodeWkupReasonReport;
  mp[lpmodeWkupReasonDavisWind] = lpmodeWkupReasonDavisWind;
  mp[lpmodeWkupReasonDavisRain] = lpmodeWkupReasonDavisRain;
  
  // Get current time. RTC counts seconds but is reset after each packet cycle.
  uint32_t nowTimeSeconds;
  rtcGetTimeSeconds(&nowTimeSeconds);

  // The package interval in seconds
  uint16_t packageIntervalSeconds = PACKET_INTERVAL_INITIAL * 60;

  /* Initialize schedule. Set to maximum possible time stamp in the future. */
  uint32_t next[lpmodeWkupReasonSize];
  for(int i = 0; i < lpmodeWkupReasonSize; i++) {
    next[i] = 0xffffffff;
  }

  /* Schedule REPORT */
  next[lpmodeWkupReasonReport] = ((nowTimeSeconds / packageIntervalSeconds) + 1) * packageIntervalSeconds;
  // If - for some reason - we missed the last packet tx (overdue), reschedule immediately
  if ( (nowTimeSeconds - ostimeLastPacketTx) >= packageIntervalSeconds) {
    next[lpmodeWkupReasonReport] = nowTimeSeconds + 1;
  }
  #if DEBUG_SERIAL
  Serial1.print(F("    Next REPORT: "));
  Serial1.println(next[lpmodeWkupReasonReport], DEC);
  #endif

  /* Schedule DAVIS_WIND */
#if EQUIP_DAVIS_WIND
  // sample every 30s
    next[lpmodeWkupReasonDavisWind] = ((nowTimeSeconds / WIND_SAMPLING_RATE) + 1) * WIND_SAMPLING_RATE;
    // Safety feature: Only schedule new wind measurements until next package is due
    if(next[lpmodeWkupReasonDavisWind] >= (next[lpmodeWkupReasonReport] - 1)) {
      next[lpmodeWkupReasonDavisWind] = 0xffffffff;
    }
    #if DEBUG_SERIAL
    Serial1.print(F("Next DAVIS_WIND: "));
    Serial1.println(next[lpmodeWkupReasonDavisWind], DEC);
    #endif
#endif

  uint8_t closestAlarm = 0;

  // Find the closest alarm
  for(int i = 1; i < lpmodeWkupReasonSize; i++) {
    if(next[i] < next[closestAlarm]) {
      closestAlarm = i;
    }
  }

  /* Register RTC event */
  rtcAlarmEvent = mp[closestAlarm];
  //Serial1.print(F("lpmodeWkupReasonDavisWind="));
  //Serial1.println(lpmodeWkupReasonDavisWind);
  // Serial1.print(F("rtcAlarmEvent="));
  // Serial1.println(rtcAlarmEvent);
  
  // Get time delta until next alarm
  return (int)(next[closestAlarm] - nowTimeSeconds);
}

/* Wake up from Real Time Clock Alarm.
 * Set global wakeup reason flag to the identical value
 * as set before going to sleep on RTC wakeup (rtcAlarmEvent).
 */
void lpmodeInterruptRTC() {
  // Serial1.print(F("wkupReason="));
  // Serial1.println(wkupReason);
  wkupReason = rtcAlarmEvent;
  // Serial1.print(F("wkupReason="));
  // Serial1.println(wkupReason);
}

/*  Wake up from Davis Rain Gauge tipping spoon interrupt event.
 *  Set global wakeup reason flag.
 */
#if EQUIP_DAVIS_RAIN
void lpmodeInterruptDavisRain() {
  wkupReason = lpmodeWkupReasonDavisRain;
}
#endif

/* Perform a reboot */
void reboot() {
  NVIC_SystemReset();
  delay(100);
}
